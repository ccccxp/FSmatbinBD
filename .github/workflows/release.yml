name: Build and Release

on:
  push:
    tags:
      - 'v*'
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      version:
        description: 'Version (e.g. 1.2.2)'
        required: false
        default: ''
      create_release:
        description: 'Create GitHub Release'
        required: false
        type: boolean
        default: false

env:
  APP_NAME: FSMatbinBD
  PYTHON_VERSION: '3.11'

jobs:
  build:
    name: Build Windows Executable
    runs-on: windows-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        lfs: true  # Ensure Git LFS files (like database) are downloaded
      
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pyinstaller
        
    - name: Get version and update version.json
      id: version
      shell: pwsh
      run: |
        # Read current version.json
        $versionJsonPath = "version.json"
        if (Test-Path $versionJsonPath) {
          $versionConfig = Get-Content -Path $versionJsonPath -Raw | ConvertFrom-Json
          $version = $versionConfig.version
        } else {
          $version = "dev"
        }
        
        # Get version from tag (if triggered by tag), priority over config
        if ("${{ github.ref }}" -match "refs/tags/v(.+)") {
          $version = $matches[1]
        }
        
        # Manual input version has highest priority
        if ("${{ github.event.inputs.version }}" -ne "") {
          $version = "${{ github.event.inputs.version }}"
        }
        
        # Get current date
        $buildDate = Get-Date -Format "yyyy-MM-dd"
        
        # Update version.json
        $versionConfig = @{
          version = $version
          build_date = $buildDate
          app_name = "${{ env.APP_NAME }}"
          description = "FromSoftware Material Binary Database"
        }
        $versionConfig | ConvertTo-Json -Depth 10 | Set-Content -Path $versionJsonPath -Encoding UTF8
        
        Write-Host "‚úì Version: $version"
        Write-Host "‚úì Build Date: $buildDate"
        Write-Host "‚úì Updated version.json"
        
        echo "VERSION=$version" >> $env:GITHUB_OUTPUT
        echo "BUILD_DATE=$buildDate" >> $env:GITHUB_OUTPUT
        
    - name: Build with PyInstaller
      run: |
        pyinstaller FSMatbinBD.spec --noconfirm
      env:
        PYTHONOPTIMIZE: 1
        
    - name: Verify build
      shell: pwsh
      run: |
        $exePath = "dist/${{ env.APP_NAME }}/${{ env.APP_NAME }}.exe"
        if (Test-Path $exePath) {
          $size = (Get-Item $exePath).Length / 1MB
          Write-Host "‚úì Build successful: $exePath"
          Write-Host "‚úì File size: $([math]::Round($size, 2)) MB"
        } else {
          Write-Error "‚úó Build failed: executable not found"
          exit 1
        }
        
    - name: Prepare release packages
      shell: pwsh
      run: |
        $version = "${{ steps.version.outputs.VERSION }}"
        
        # Copy README and configs
        Copy-Item README.md dist/${{ env.APP_NAME }}/ -ErrorAction SilentlyContinue
        Copy-Item README_CN.md dist/${{ env.APP_NAME }}/ -ErrorAction SilentlyContinue
        
        # Ensure auxiliary directories exist (dirs needed by user at runtime)
        New-Item -ItemType Directory -Force -Path dist/${{ env.APP_NAME }}/temp | Out-Null
        New-Item -ItemType Directory -Force -Path dist/${{ env.APP_NAME }}/output | Out-Null
        New-Item -ItemType Directory -Force -Path dist/${{ env.APP_NAME }}/logs | Out-Null
        
        # Check if database exists in internal/data/databases/
        $dbPath = "dist/${{ env.APP_NAME }}/internal/data/databases/materials.db"
        if (Test-Path $dbPath) {
          $dbSize = (Get-Item $dbPath).Length / 1MB
          Write-Host "‚úì Database file exists: $([math]::Round($dbSize, 2)) MB"
          
          # Copy database file to root for standalone release
          Copy-Item $dbPath "materials.db"
          Write-Host "‚úì Extracted database file: materials.db"
        } else {
          Write-Host "‚ö† Database file missing: $dbPath"
          # Ensure data/databases directory exists (for lite version)
          New-Item -ItemType Directory -Force -Path "dist/${{ env.APP_NAME }}/internal/data/databases" | Out-Null
        }
        
    - name: Create Full ZIP (with database)
      shell: pwsh
      run: |
        $version = "${{ steps.version.outputs.VERSION }}"
        $zipName = "${{ env.APP_NAME }}_v${version}_Windows_x64_Full.zip"
        Compress-Archive -Path dist/${{ env.APP_NAME }}/* -DestinationPath $zipName -Force
        
        $zipSize = (Get-Item $zipName).Length / 1MB
        Write-Host "‚úì Full package: $zipName ($([math]::Round($zipSize, 2)) MB)"
        
    - name: Create Lite ZIP (without database)
      shell: pwsh
      run: |
        $version = "${{ steps.version.outputs.VERSION }}"
        $zipName = "${{ env.APP_NAME }}_v${version}_Windows_x64_Lite.zip"
        
        # Remove database file
        $dbPath = "dist/${{ env.APP_NAME }}/internal/data/databases/materials.db"
        if (Test-Path $dbPath) {
          Remove-Item $dbPath -Force
          Write-Host "‚úì Database file removed"
        }
        
        # Create empty .gitkeep to maintain directory structure
        New-Item -ItemType File -Force -Path "dist/${{ env.APP_NAME }}/internal/data/databases/.gitkeep" | Out-Null
        
        Compress-Archive -Path dist/${{ env.APP_NAME }}/* -DestinationPath $zipName -Force
        
        $zipSize = (Get-Item $zipName).Length / 1MB
        Write-Host "‚úì Lite package: $zipName ($([math]::Round($zipSize, 2)) MB)"
        
    - name: Upload Full artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.APP_NAME }}_v${{ steps.version.outputs.VERSION }}_Windows_x64_Full
        path: ${{ env.APP_NAME }}_v${{ steps.version.outputs.VERSION }}_Windows_x64_Full.zip
        retention-days: 30
        
    - name: Upload Lite artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.APP_NAME }}_v${{ steps.version.outputs.VERSION }}_Windows_x64_Lite
        path: ${{ env.APP_NAME }}_v${{ steps.version.outputs.VERSION }}_Windows_x64_Lite.zip
        retention-days: 30
        
    - name: Upload Database artifact
      uses: actions/upload-artifact@v4
      if: ${{ hashFiles('materials.db') != '' }}
      with:
        name: materials_database
        path: materials.db
        retention-days: 30

  release:
    name: Create GitHub Release
    needs: build
    runs-on: ubuntu-latest
    # Run ONLY on tag push OR manual trigger when create_release is true
    if: startsWith(github.ref, 'refs/tags/v') || (github.event_name == 'workflow_dispatch' && github.event.inputs.create_release == 'true')
    
    permissions:
      contents: write
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Get version
      id: version
      run: |
        if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          VERSION="${GITHUB_REF#refs/tags/v}"
        elif [[ -n "${{ github.event.inputs.version }}" ]]; then
          VERSION="${{ github.event.inputs.version }}"
        else
          VERSION="dev"
        fi
        echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
        echo "Version: $VERSION"
        
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        merge-multiple: true
        
    - name: Generate Release Notes
      id: release_notes
      shell: python
      env:
        VERSION: ${{ steps.version.outputs.VERSION }}
      run: |
        import os
        import re
        import sys
        import uuid
        import textwrap

        version = os.environ.get('VERSION', 'dev')
        
        # 1. Parse CHANGELOG.md
        changelog_content = ""
        current_version_notes = []
        try:
            if os.path.exists('CHANGELOG.md'):
                with open('CHANGELOG.md', 'r', encoding='utf-8') as f:
                    lines = f.readlines()
                    
                capturing = False
                for line in lines:
                    # Match version header: ## [1.2.2]
                    match = re.search(r'^##\s+\[([^\]]+)\]', line)
                    if match:
                        if match.group(1) == version:
                            capturing = True
                            continue
                        elif capturing:
                            # Stop at next version header
                            break
                    
                    if capturing:
                        current_version_notes.append(line)
                        
                changelog_content = "".join(current_version_notes).strip()
            else:
                print("CHANGELOG.md not found")
        except Exception as e:
            print(f"Error parsing CHANGELOG.md: {e}")
            
        if not changelog_content:
            changelog_content = f"Release {version}"

        # 2. List Files and Sizes
        file_table = "| File | Size | Description |\n|---|---|---|\n"
        files_found = False
        
        for file in os.listdir('.'):
            if not os.path.isfile(file):
                continue
                
            if file.endswith('.zip') or file.endswith('.db'):
                size_mb = os.path.getsize(file) / (1024 * 1024)
                desc = "Release Package"
                if "Full" in file:
                    desc = "**Full Version** (Includes Database)"
                elif "Lite" in file:
                    desc = "**Lite Version** (No Database)"
                elif "materials.db" in file:
                    desc = "Database Standalone"
                    
                file_table += f"| `{file}` | {size_mb:.2f} MB | {desc} |\n"
                files_found = True
                
        if not files_found:
            file_table = "No release files found."

        # 3. Construct Final Body
        body = textwrap.dedent(f"""\
            ## FSMatbinBD v{version}

            ### üìù What's New
            {changelog_content}

            ### üì¶ Downloads
            {file_table}

            ### üöÄ Installation
            **Full Version**: Extract and run `FSMatbinBD.exe`.
            **Lite Version**: Extract, then place `materials.db` into `internal/data/databases/`.
            """)
        
        # Write to file
        with open('release_notes.md', 'w', encoding='utf-8') as f:
            f.write(body)
            
    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        name: FSMatbinBD v${{ steps.version.outputs.VERSION }}
        tag_name: v${{ steps.version.outputs.VERSION }}
        body_path: release_notes.md
        files: |
          *.zip
          *.db
        draft: false
        prerelease: ${{ contains(steps.version.outputs.VERSION, 'beta') || contains(steps.version.outputs.VERSION, 'alpha') || contains(steps.version.outputs.VERSION, 'rc') }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

